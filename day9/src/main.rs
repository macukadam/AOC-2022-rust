use std::{collections::HashSet, fmt::Display, str::FromStr, thread, time::Duration};

#[derive(Debug)]
enum Move {
    L(i32),
    R(i32),
    U(i32),
    D(i32),
}

struct Moves {
    moves: Vec<Move>,
}

impl FromStr for Moves {
    type Err = TerribleError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let moves = s.lines().map(|x| Move::from_str(x).unwrap()).collect();
        Ok(Self { moves })
    }
}

#[derive(Debug)]
struct TerribleError {}
impl std::error::Error for TerribleError {}

impl Display for TerribleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Input can't be parset do a Move.")
    }
}

impl FromStr for Move {
    type Err = Box<dyn std::error::Error>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let split = s.split_once(" ").unwrap();
        let count = split.1.parse().unwrap();
        match split.0 {
            "L" => Ok(Move::L(count)),
            "R" => Ok(Move::R(count)),
            "U" => Ok(Move::U(count)),
            "D" => Ok(Move::D(count)),
            _ => Err(Box::new(TerribleError {})),
        }
    }
}

fn main() {
    let input = std::fs::read_to_string("9_input.txt").unwrap();
    let mut set = HashSet::<(i32, i32)>::new();
    let mut head = (0, 0);
    let mut tail = (0, 0);

    let moves = Moves::from_str(&input).unwrap();

    set.insert(tail);

    for m in &moves.moves {
        let head_pos: Vec<(i32, i32)> = match m {
            Move::L(steps) => (0..=*steps).map(|x| (head.0 - x, head.1)).collect(),
            Move::R(steps) => (0..=*steps).map(|x| (head.0 + x, head.1)).collect(),
            Move::D(steps) => (0..=*steps).map(|x| (head.0, head.1 - x)).collect(),
            Move::U(steps) => (0..=*steps).map(|x| (head.0, head.1 + x)).collect(),
        };

        for pos in head_pos {
            head = pos;
            let diff = (head.0 - tail.0, pos.1 - tail.1);
            tail = match diff {
                (2, 1) | (1, 2) => (tail.0 + 1, tail.1 + 1),
                (2, -1) | (1, -2) => (tail.0 + 1, tail.1 - 1),
                (-1, 2) | (-2, 1) => (tail.0 - 1, tail.1 + 1),
                (-1, -2) | (-2, -1) => (tail.0 - 1, tail.1 - 1),
                (2, 0) => (tail.0 + 1, tail.1),
                (0, 2) => (tail.0, tail.1 + 1),
                (0, -2) => (tail.0, tail.1 - 1),
                (-2, 0) => (tail.0 - 1, tail.1),
                _ => tail,
            };

            set.insert(tail);
        }
    }

    println!("{}", set.len());
    head = (0, 0);
    set = HashSet::<(i32, i32)>::new();
    let mut tails = [(0, 0); 9];

    set.insert(tails[8]);

    for m in &moves.moves {
        let head_pos: Vec<(i32, i32)> = match m {
            Move::L(steps) => (0..=*steps).map(|x| (head.0 - x, head.1)).collect(),
            Move::R(steps) => (0..=*steps).map(|x| (head.0 + x, head.1)).collect(),
            Move::D(steps) => (0..=*steps).map(|x| (head.0, head.1 - x)).collect(),
            Move::U(steps) => (0..=*steps).map(|x| (head.0, head.1 + x)).collect(),
        };

        for pos in head_pos {
            head = pos;
            let mut ref_to_tail = head;
            for tail in tails.iter_mut() {
                let diff = (ref_to_tail.0 - tail.0, ref_to_tail.1 - tail.1);

                *tail = match diff {
                    (2, 1) | (1, 2) | (2, 2) => (tail.0 + 1, tail.1 + 1),
                    (2, -1) | (1, -2) | (2, -2) => (tail.0 + 1, tail.1 - 1),
                    (-1, 2) | (-2, 1) | (-2, 2) => (tail.0 - 1, tail.1 + 1),
                    (-1, -2) | (-2, -1) | (-2, -2) => (tail.0 - 1, tail.1 - 1),
                    (2, 0) => (tail.0 + 1, tail.1),
                    (0, 2) => (tail.0, tail.1 + 1),
                    (0, -2) => (tail.0, tail.1 - 1),
                    (-2, 0) => (tail.0 - 1, tail.1),
                    _ => *tail,
                };

                ref_to_tail = *tail;
            }
            set.insert(tails[8]);
            // print_to_console(head, tails.to_vec());
        }
    }

    println!("{}", set.len());
}

fn print_to_console(t: (i32, i32), v: Vec<(i32, i32)>) {
    let mut console: Vec<Vec<char>> =
        r#"--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------"#
            .lines()
            .map(|x| x.chars().collect())
            .collect();

    console[(20 + t.1) as usize][(20 + t.0) as usize] = 'H';
    for (i, val) in v.iter().enumerate() {
        console[(20 + val.1) as usize][(20 + val.0) as usize] =
            char::from_digit((i + 1) as u32, 10).unwrap();
    }

    let oow: String = console
        .iter()
        .map(|x| x.iter().collect::<String>())
        .collect::<Vec<String>>()
        .join("\n");


    println!("{}", oow);

    thread::sleep(Duration::from_micros(10000));

    print!("\x1B[2J\x1B[1;1H");
}
